数据类型：
有符号整形变二进制 按位取反再加1；（有符号->无符号读取）
Eg：-4；  0100-->1011->(加一)->1100->(最终二进制为11111111 11111111 11111111 11111100)（40几亿）
含有有/无符号类型的计算中：
有符号类型向无符号类型提升

C语言五大分区：
1、栈区（stack）由编译器自动分配释放 ，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。 
能写入，能读出
2、堆区（heap） 一般由程序员分配释放， 若程序员不释放，程序结束时可能由OS回收 。注意它与数据结构中的堆是两回事，分配方式倒是类似于链表，呵呵。 
3、全局区（静态区）（static）—，全局变量和静态变量的存储是放在一块的，初始化的全局变量和静态变量在一块区域， 未初始化的全局变量和未初始化的静态变量在相邻的另一块区域。 - 程序结束后有系统释放 
4、文字常量区 —常量字符串就是放在这里的。 程序结束后由系统释放 。能读不能写
5、程序代码区—存放函数体的二进制代码

全局变量/静态变量的区别：
全局变量是不显式用baistatic修饰的全局变量du，但全局变量默认是动态的，作用域是整zhi个工程，在一个文件dao内定义的全局变量，在另一个文件中，通过extern 全局变量名的声明，就可以使用全局变量。全局静态变量是显式用static修饰的全局变量，作用域是声明此变量所在的文件，其他的文件即使用extern声明也不能使用。
拓展资料：
全局变量也称为外部变量，它是在 函数外部定义的变量。 它不属于哪一个 函数，它属于一个源程序文件。其作用域是从定义该变量的位置开始至源文件结束。
全局变量是在所有函数体的外部定义的，程序的所在部分（甚至其它文件中的代码）都可以使用。全局变量不受作用域的影响（也就是说，全局变量的生命期一直到程序的结束）。如果在一个文件中使用 extern关键字来声明另一个文件中存在的全局变量，那么这个文件可以使用这个数据。
在全局变量前加一个 static，使该变量只在这个源文件中可用，称之为全局静态变量，全局静态变量就是静态全局变量。
在多文件组成的程序里，全局变量与全局静态变量是不同的。在某一层次声明的变量的作用域就终止于该变量所在层次的末尾。唯一的区别是全局静态变量使得该变量成为定义该变量的源文件所独享。如果在一个文件中使用 extern关键字来声明另一个文件中存在的静态全局变量，这个文件也不能够使用这个数据。

栈区和堆区的区别：
1)申请方式： 栈区内存由系统自动分配，函数结束时释放；堆区内存由程序员自己申请，并指明大小，用户忘释放时，会造成内存泄露，不过进程结束时会由系统回收。
2)存储内容：栈，函数调用（返回值，各个参数，局部变量（静态变量不入栈））；堆，一般在堆的头部用一个字节存放堆的大小，堆中的具体内容由程序员安排。
3)存取效率的比较：栈比堆快，Eg :char c[] = /"1234567890/";char *p =/"1234567890/";读取c[1]和p[1],c[1]读取时直接吧字符串中的元素读到寄存器cl中，而p[1]先把指针值读到edx中，再根据edx读取字符，多一次操作。
4)管理方式不同：栈，数据结构中的栈；堆，链表
5)生长方向：栈，（地址分配由）高到低；堆，低到高
6)生命周期：栈，{}结束；堆，free（）结束
7)申请后系统的响应： 只要栈的剩余空间大于所申请的空间，系统将为程序提供内存，否则将报异常提示栈溢出；堆区，空闲链表，分配与回收机制，会产生碎片问题（外部碎片）-->（固定分区存在内部碎片（分配大于实际），可变分区存在外部碎片（太碎无法分配））。
8)申请大小的限制：栈是1或者2M，可以自己改，但是最大不超过8M；堆，看主机是多少位的，如果是32位，就是4G
9)申请效率：栈由系统自动分配，速度较快，程序员无法控制；堆是由new分配的内存，一般速度较慢，而且容易导致内存碎片，但是用起来方便！

堆和栈的理论知识
1、申请方式
stack：由系统自动分配，例如声明在函数中的一个局部变量int b;系统自动在栈中为b开辟空间。
heap：需要程序员自己申请，并指明大小，在C中用malloc函数：p1=(char*)malloc(10);在C++中用new运算符：p2=new char[10]。注意p1、p2本身是在栈中的。
2、申请后系统的响应
栈：只要栈的剩余空间大于所申请空间，系统将为程序提供内存，否则将报异常提示栈溢出。
堆：首先应该知道操作系统有一个记录空闲内存地址的链表，当系统收到程序的申请时，会遍历该链表，寻找第一个空间大于所申请空间的堆结点，然后将该结点从空闲结点链表中删除，并将该结点的空间分配给程序，另外，对于大多数系统，会在这块内存空间中的首地址处记录本次分配的大小，这样，代码中的delete语句才能正确的释放本内存空间。另外，由于找到的堆结点的大小不一定正好等于申请的大小，系统会自动的将多余的那部分重新放入空闲链表中。
3、申请大小的限制
栈：在Windows下,栈是向低地址扩展的数据结构，是一块连续的内存的区域。这句话的意思是栈顶的地址和栈的最大容量是系统预先规定好的，在WINDOWS下，栈的大小是2M（也有的说是1M，总之是一个编译时就确定的常数），如果申请的空间超过栈的剩余空间时，将提示overflow。因此，能从栈获得的空间较小。
堆：堆是向高地址扩展的数据结构，是不连续的内存区域。这是由于系统是用链表来存储的空闲内存地址的，自然是不连续的，而链表的遍历方向是由低地址向高地址。堆的大小受限于计算机系统中有效的虚拟内存。由此可见，堆获得的空间比较灵活，也比较大。
4、申请效率的比较
栈：由系统自动分配，速度较快。但程序员是无法控制的。
堆：是由new分配的内存，一般速度比较慢，而且容易产生内存碎片,不过用起来最方便.
另外，在WINDOWS下，最好的方式是用Virtual Alloc分配内存，它不是在堆，也不是在栈,而是直接在进程的地址空间中保留一块内存，虽然用起来最不方便。但是速度快，也最灵活。
5、堆和栈中的存储内容
栈：在函数调用时，第一个进栈的是主函数后的下一条指令（函数调用语句的下一条可执行语句）的地址，然后是函数的各个参数，在大多数的C编译器中，参数是由右往左入栈的，然后是函数中的局部变量。注意静态变量是不入栈的。当本次函数调用结束后，局部变量先出栈，然后是参数，最后栈顶指针指向最开始存的地址，也就是主函数中的下一条指令，程序由该点继续运行。
堆：一般是在堆的头部用一个字节存放堆的大小。堆中的具体内容由程序员安排。
6、存取效率的比较
char s1[]="aaaaaaaaaaaaaaa";
char *s2="bbbbbbbbbbbbbbbbb";
aaaaaaaaaaa是在运行时刻赋值的；而bbbbbbbbbbb是在编译时就确定的；但是，在以后的存取中，在栈上的数组比指针所指向的字符串(例如堆)快。

简述什么是地址传递和值传递,并简述两者的区别：
值传递只是将变量的内容复制一份而已，函数进行操作的其实是另一个变量，只是另一个变量的值和传递的变量值是相同的。
而地址传递是直接把变量的地址传递给函数，这时函数是直接对原来的变量进行操作的。所以值会变化。

什么是 值传递，地址传递和引用传递 有什么区别
1）#include <stdio.h>
void swap1(int x,int y)
{
    int temp = x;
    x = y;
    y = temp;
    printf("x=%d,y=%d\n",x,y);
}
int main()
{
    int a = 2,b = 7;
    swap1(a,b);
    printf("a=%d,b=%d\n",a,b);
}
//输出
//x=7,y=2
//a=2,b=7
值传递。swap1函数的操作是将x，y进行对调。需要注意的是，对形参的操作不会影响到a，b。我们可以设想，在swap1函数执行语句的最前面，隐含地存在x=a; y=b;这两条语句，这样就便于理解了。当a，b把值赋给x，y之后，对x，y不论再做什么操作，都不会影响到a，b本身。
2）#include <stdio.h>
void swap2(int *px,int *py)
{
    int temp = *px;
    *px = *py;
    *py = temp;
    printf("*px=%d,*py=%d\n",*px,*py);
}
int main()
{
    int a = 2,b = 7;
    swap2(&a,&b);
    printf("a=%d,b=%d\n",a,b);
}
//输出
//*px=7,*py=2
//a=7,b=2
地址传递。注意，这时的函数的声明和调用的写法与值传递不同。
函数声明：swap2(int *px, int *py)
函数调用：swap2(&a, &b)
但是与值传递的分析一样，我们同样可以设想，在swap2函数里，隐含地存在px=&a; py=&b;这两条语句，这表示a的地址代入到了px，b的地址代入到了py。这样一来，对*px, *py的操作就是a，b本身的操作。所以a，b的值被对调了。
3）#include <stdio.h>
void swap3(int &x,int &y)
{
    int temp = x;
    x = y;
    y = temp;
    printf("x=%d,y=%d\n",x,y);
}
int main()
{
    int a = 2,b = 7;
    swap3(a,b);
    printf("a=%d,b=%d\n",a,b);
}
//输出
//x=7,y=2
//a=7,b=2
引用传递。先看函数的声明和调用的写法，函数调用和值传递的写法是一样的，但是函数声明是不一样的。
函数声明：swap3(int &x, int &y)
函数调用：swap3(a, b)
因为定义的x，y前面有&取地址符，调用函数swap3时，a，b分别代替了x，y，即x，y分别引用了a，b变量。因此，函数里的操作，实际上是对实参a，b本身的操作，其值发生了对调。

Char *str 与char str[]的区别：
char str[]="abcdef"，这个数组的存储空间是在栈中开辟的，也就是说它的每个元素一次为'a','b','c','\0'，将这几个值复制到str的位置中。
对于char *str="abcdef"，str指向的是静态存储区，"abcdef"是位于常量区的，指针str只是指向了这个位置。注意：它与上面的复制不是一回事。既然位于常量区，那么这些值就不能被修改。而上面数组中，要注意的是把字符复制到数组的元素中，那么就是可以被任意修改的。
